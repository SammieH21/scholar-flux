# import dependencies
from __future__ import annotations
from typing import Union
import logging
from typing import Any, ClassVar
from dataclasses import dataclass
from scholar_flux.utils.paths.processing_paths import ProcessingPath
from scholar_flux.exceptions.path_exceptions import (
    PathIndexingError,
    InvalidPathNodeError,
)

# Configure logging
logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class PathNode:
    """
    A dataclass that provides a wrapper for both the path (key) and the value (Any)
    Simplifies the process of manipulating and flattening data originating from JSON.

    Attributes:
        path (ProcessingPath): The terminal path where the value was located
        value (Any) The value to associate with the current path:
    """

    path: ProcessingPath
    value: Any
    DEFAULT_DELIMITER: ClassVar[str] = ProcessingPath.DEFAULT_DELIMITER

    def __post_init__(self):
        if not isinstance(self.path, ProcessingPath):
            raise InvalidPathNodeError(
                f"Error creating PathNode: expected a ProcessingPath for path, received {type(self.path)}"
            )

    def update(self, **attributes: Union[ProcessingPath, Any]) -> PathNode:
        """
        Update the parameters of a PathNode by creating a new PathNode instance.
        Note that the original PathNode dataclass is frozen. This method uses
        the copied dict originating from the dataclass to initialize a new PathNode.
        Args:
            **attributes (dict): keyword arguments indicating the attributes of the
            PathNode to update. If a specific key is not provided, then it will not update
            Each key should be a valid attribute name of PathNode,
            and each value should be the corresponding updated value.

        Returns:
            A new path with the updated attributes
        """
        parameter_dict = self.__dict__.copy() | attributes
        return PathNode(**parameter_dict)

    @property
    def path_keys(self) -> ProcessingPath:
        """
        Utility function for retaining keys from a path, ignoring indexes generated by lists
        Retrieves the original path minus all keys that originate from list indexes

        Returns:
            ProcessingPath: A ProcessingPath instance associated with all dictionary keys
        """

        return self.path.remove_indices()

    @property
    def path_group(self) -> ProcessingPath:
        """
        Attempt to retrieve the path omitting the last element if it is numeric.
        The remaining integers are replaced with a placeholder (i).
        This is later useful for when we need to group paths into a list or sets
        in order to consolidate record fields.

        Returns:
            ProcessingPath: A ProcessingPath instance with the last numeric component removed and indices replaced.
        """
        return self.path.group()

    @property
    def record_index(self) -> int:
        """
        Extract the first element of a page to determine the record number originating
        from a list of dictionaries

        Returns:
            int: Value denoting the record that the path originates from
        """
        try:
            idx = self.path.components[0]
            return int(idx)
        except (IndexError, TypeError) as e:
            raise PathIndexingError(
                f"The first element of the current path, '{self.path}',  cannot be indexed as a record: {e}"
            )

    @classmethod
    def is_valid_node(cls, node) -> bool:
        if not isinstance(node, PathNode):
            raise InvalidPathNodeError(
                f"The current object is not a PathNode: expected 'PathNode', received {type(node)}"
            )

        if not isinstance(node.path, ProcessingPath):
            raise InvalidPathNodeError(
                f"The current path of the validated node is not a ProcessingPath: expected ProcessingPath, received {type(node.path)}"
            )

        return True

    def __hash__(self) -> int:
        """
        For hashing nodes based on their path hash.
        This creates a unique identifier for the dictionary hash assuming paths
        are not duplicated.

        Returns:
            int: hash of the current path node
        """
        return self.path.__hash__()

    def __lt__(self, other: PathNode) -> bool:
        """
        Check if the node of the current path is a subset of the given path

        Args:
            path (ProcessingPath): The path to compare against.

        Returns:
            bool: True if self is a subset of path and has a different depth, otherwise False.
        """
        return self.path < other.path

    def __le__(self, other: PathNode) -> bool:
        """
        Check if the current path is equal to or a subset of the given path.

        Args:
            path (ProcessingPath): The path to compare against.

        Returns:
            bool: True if self is equal to or a subset of path, otherwise False.
        """
        return self.path < other.path or self == other

    def __gt__(self, other: PathNode) -> bool:
        """
        Check if the current path strictly contains the given path.

        Args:
            path (ProcessingPath): The path to compare against.

        Returns:
            bool: True if self strictly contains path, otherwise False.
        """
        return self.path > other.path

    def __ge__(self, other: PathNode) -> bool:
        """
        Check if the current path is equal to or strictly contains the given path.

        Args:
            path (PathNode): The path to compare against.

        Returns:
            bool: True if self is equal to or strictly contains path, otherwise False.
        """
        return self.path > other.path or self == other

    def __eq__(self, other: object) -> bool:
        """Check equality with another PathNode, string, or list of strings.

        Args:
            other (object): The object to compare with.

        Returns:
            bool: True if the objects are equal, False otherwise.
        """
        return isinstance(other, PathNode) and self.path == other.path and self.value == other.value
